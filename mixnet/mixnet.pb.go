// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mixnet.proto

/*
	Package mixnet is a generated protocol buffer package.

	It is generated from these files:
		mixnet.proto

	It has these top-level messages:
		NewRoundRequest
		NewRoundResponse
		EndRoundRequest
		EndRoundResponse
		AddMessagesRequest
		AddMessagesResponse
		StartRoundRequest
		StartRoundResponse
		GetMessagesRequest
		GetMessagesResponse
		SubmitCiphertextsRequest
		SubmitCiphertextsResponse
		VerifyProofRequest
		VerifyProofResponse
		ConfirmVerificationRequest
		ConfirmVerificationResponse
		PrivateKey
		PublicKey
		Ciphertext
		GetInnerKeyRequest
		GetInnerKeyResponse
		AddInnerCiphertextsRequest
		AddInnerCiphertextsResponse
		GetPrivateInnerKeyRequest
		GetPrivateInnerKeyResponse
		FinalizeRequest
		FinalizeResponse
*/
package mixnet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Source int32

const (
	Source_CLIENT Source = 0
	Source_SERVER Source = 1
)

var Source_name = map[int32]string{
	0: "CLIENT",
	1: "SERVER",
}
var Source_value = map[string]int32{
	"CLIENT": 0,
	"SERVER": 1,
}

func (x Source) String() string {
	return proto.EnumName(Source_name, int32(x))
}
func (Source) EnumDescriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{0} }

type NewRoundRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *NewRoundRequest) Reset()                    { *m = NewRoundRequest{} }
func (m *NewRoundRequest) String() string            { return proto.CompactTextString(m) }
func (*NewRoundRequest) ProtoMessage()               {}
func (*NewRoundRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{0} }

func (m *NewRoundRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type NewRoundResponse struct {
}

func (m *NewRoundResponse) Reset()                    { *m = NewRoundResponse{} }
func (m *NewRoundResponse) String() string            { return proto.CompactTextString(m) }
func (*NewRoundResponse) ProtoMessage()               {}
func (*NewRoundResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{1} }

type EndRoundRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *EndRoundRequest) Reset()                    { *m = EndRoundRequest{} }
func (m *EndRoundRequest) String() string            { return proto.CompactTextString(m) }
func (*EndRoundRequest) ProtoMessage()               {}
func (*EndRoundRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{2} }

func (m *EndRoundRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type EndRoundResponse struct {
}

func (m *EndRoundResponse) Reset()                    { *m = EndRoundResponse{} }
func (m *EndRoundResponse) String() string            { return proto.CompactTextString(m) }
func (*EndRoundResponse) ProtoMessage()               {}
func (*EndRoundResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{3} }

type AddMessagesRequest struct {
	Round    uint64   `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
	Messages [][]byte `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
}

func (m *AddMessagesRequest) Reset()                    { *m = AddMessagesRequest{} }
func (m *AddMessagesRequest) String() string            { return proto.CompactTextString(m) }
func (*AddMessagesRequest) ProtoMessage()               {}
func (*AddMessagesRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{4} }

func (m *AddMessagesRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *AddMessagesRequest) GetMessages() [][]byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

type AddMessagesResponse struct {
}

func (m *AddMessagesResponse) Reset()                    { *m = AddMessagesResponse{} }
func (m *AddMessagesResponse) String() string            { return proto.CompactTextString(m) }
func (*AddMessagesResponse) ProtoMessage()               {}
func (*AddMessagesResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{5} }

type StartRoundRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *StartRoundRequest) Reset()                    { *m = StartRoundRequest{} }
func (m *StartRoundRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRoundRequest) ProtoMessage()               {}
func (*StartRoundRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{6} }

func (m *StartRoundRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type StartRoundResponse struct {
}

func (m *StartRoundResponse) Reset()                    { *m = StartRoundResponse{} }
func (m *StartRoundResponse) String() string            { return proto.CompactTextString(m) }
func (*StartRoundResponse) ProtoMessage()               {}
func (*StartRoundResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{7} }

type GetMessagesRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *GetMessagesRequest) Reset()                    { *m = GetMessagesRequest{} }
func (m *GetMessagesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMessagesRequest) ProtoMessage()               {}
func (*GetMessagesRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{8} }

func (m *GetMessagesRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type GetMessagesResponse struct {
	Messages [][]byte `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
}

func (m *GetMessagesResponse) Reset()                    { *m = GetMessagesResponse{} }
func (m *GetMessagesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMessagesResponse) ProtoMessage()               {}
func (*GetMessagesResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{9} }

func (m *GetMessagesResponse) GetMessages() [][]byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

type SubmitCiphertextsRequest struct {
	Round       uint64   `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
	Ciphertexts [][]byte `protobuf:"bytes,2,rep,name=ciphertexts" json:"ciphertexts,omitempty"`
	Proofs      [][]byte `protobuf:"bytes,3,rep,name=proofs" json:"proofs,omitempty"`
}

func (m *SubmitCiphertextsRequest) Reset()                    { *m = SubmitCiphertextsRequest{} }
func (m *SubmitCiphertextsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitCiphertextsRequest) ProtoMessage()               {}
func (*SubmitCiphertextsRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{10} }

func (m *SubmitCiphertextsRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *SubmitCiphertextsRequest) GetCiphertexts() [][]byte {
	if m != nil {
		return m.Ciphertexts
	}
	return nil
}

func (m *SubmitCiphertextsRequest) GetProofs() [][]byte {
	if m != nil {
		return m.Proofs
	}
	return nil
}

type SubmitCiphertextsResponse struct {
}

func (m *SubmitCiphertextsResponse) Reset()                    { *m = SubmitCiphertextsResponse{} }
func (m *SubmitCiphertextsResponse) String() string            { return proto.CompactTextString(m) }
func (*SubmitCiphertextsResponse) ProtoMessage()               {}
func (*SubmitCiphertextsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{11} }

type VerifyProofRequest struct {
	Round uint64   `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
	Index uint32   `protobuf:"fixed32,2,opt,name=index,proto3" json:"index,omitempty"`
	Keys  [][]byte `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	Proof []byte   `protobuf:"bytes,5,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *VerifyProofRequest) Reset()                    { *m = VerifyProofRequest{} }
func (m *VerifyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyProofRequest) ProtoMessage()               {}
func (*VerifyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{12} }

func (m *VerifyProofRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VerifyProofRequest) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *VerifyProofRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *VerifyProofRequest) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

type VerifyProofResponse struct {
}

func (m *VerifyProofResponse) Reset()                    { *m = VerifyProofResponse{} }
func (m *VerifyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyProofResponse) ProtoMessage()               {}
func (*VerifyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{13} }

type ConfirmVerificationRequest struct {
	Round    uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
	Verified bool   `protobuf:"varint,2,opt,name=verified,proto3" json:"verified,omitempty"`
}

func (m *ConfirmVerificationRequest) Reset()         { *m = ConfirmVerificationRequest{} }
func (m *ConfirmVerificationRequest) String() string { return proto.CompactTextString(m) }
func (*ConfirmVerificationRequest) ProtoMessage()    {}
func (*ConfirmVerificationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMixnet, []int{14}
}

func (m *ConfirmVerificationRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ConfirmVerificationRequest) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

type ConfirmVerificationResponse struct {
}

func (m *ConfirmVerificationResponse) Reset()         { *m = ConfirmVerificationResponse{} }
func (m *ConfirmVerificationResponse) String() string { return proto.CompactTextString(m) }
func (*ConfirmVerificationResponse) ProtoMessage()    {}
func (*ConfirmVerificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMixnet, []int{15}
}

type PrivateKey struct {
	X []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
}

func (m *PrivateKey) Reset()                    { *m = PrivateKey{} }
func (m *PrivateKey) String() string            { return proto.CompactTextString(m) }
func (*PrivateKey) ProtoMessage()               {}
func (*PrivateKey) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{16} }

func (m *PrivateKey) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

type PublicKey struct {
	X []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	Y []byte `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *PublicKey) Reset()                    { *m = PublicKey{} }
func (m *PublicKey) String() string            { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()               {}
func (*PublicKey) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{17} }

func (m *PublicKey) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *PublicKey) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

type Ciphertext struct {
	X       []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	Y       []byte `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
	Message []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Ciphertext) Reset()                    { *m = Ciphertext{} }
func (m *Ciphertext) String() string            { return proto.CompactTextString(m) }
func (*Ciphertext) ProtoMessage()               {}
func (*Ciphertext) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{18} }

func (m *Ciphertext) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *Ciphertext) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *Ciphertext) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

type GetInnerKeyRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *GetInnerKeyRequest) Reset()                    { *m = GetInnerKeyRequest{} }
func (m *GetInnerKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInnerKeyRequest) ProtoMessage()               {}
func (*GetInnerKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{19} }

func (m *GetInnerKeyRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type GetInnerKeyResponse struct {
	X []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	Y []byte `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *GetInnerKeyResponse) Reset()                    { *m = GetInnerKeyResponse{} }
func (m *GetInnerKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInnerKeyResponse) ProtoMessage()               {}
func (*GetInnerKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{20} }

func (m *GetInnerKeyResponse) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *GetInnerKeyResponse) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

type AddInnerCiphertextsRequest struct {
	Round    uint64   `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
	Messages [][]byte `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
}

func (m *AddInnerCiphertextsRequest) Reset()         { *m = AddInnerCiphertextsRequest{} }
func (m *AddInnerCiphertextsRequest) String() string { return proto.CompactTextString(m) }
func (*AddInnerCiphertextsRequest) ProtoMessage()    {}
func (*AddInnerCiphertextsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMixnet, []int{21}
}

func (m *AddInnerCiphertextsRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *AddInnerCiphertextsRequest) GetMessages() [][]byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

type AddInnerCiphertextsResponse struct {
}

func (m *AddInnerCiphertextsResponse) Reset()         { *m = AddInnerCiphertextsResponse{} }
func (m *AddInnerCiphertextsResponse) String() string { return proto.CompactTextString(m) }
func (*AddInnerCiphertextsResponse) ProtoMessage()    {}
func (*AddInnerCiphertextsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMixnet, []int{22}
}

type GetPrivateInnerKeyRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *GetPrivateInnerKeyRequest) Reset()                    { *m = GetPrivateInnerKeyRequest{} }
func (m *GetPrivateInnerKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPrivateInnerKeyRequest) ProtoMessage()               {}
func (*GetPrivateInnerKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{23} }

func (m *GetPrivateInnerKeyRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type GetPrivateInnerKeyResponse struct {
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
}

func (m *GetPrivateInnerKeyResponse) Reset()         { *m = GetPrivateInnerKeyResponse{} }
func (m *GetPrivateInnerKeyResponse) String() string { return proto.CompactTextString(m) }
func (*GetPrivateInnerKeyResponse) ProtoMessage()    {}
func (*GetPrivateInnerKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMixnet, []int{24}
}

func (m *GetPrivateInnerKeyResponse) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

type FinalizeRequest struct {
	Round uint64 `protobuf:"fixed64,1,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *FinalizeRequest) Reset()                    { *m = FinalizeRequest{} }
func (m *FinalizeRequest) String() string            { return proto.CompactTextString(m) }
func (*FinalizeRequest) ProtoMessage()               {}
func (*FinalizeRequest) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{25} }

func (m *FinalizeRequest) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type FinalizeResponse struct {
	Plaintexts [][]byte `protobuf:"bytes,1,rep,name=plaintexts" json:"plaintexts,omitempty"`
}

func (m *FinalizeResponse) Reset()                    { *m = FinalizeResponse{} }
func (m *FinalizeResponse) String() string            { return proto.CompactTextString(m) }
func (*FinalizeResponse) ProtoMessage()               {}
func (*FinalizeResponse) Descriptor() ([]byte, []int) { return fileDescriptorMixnet, []int{26} }

func (m *FinalizeResponse) GetPlaintexts() [][]byte {
	if m != nil {
		return m.Plaintexts
	}
	return nil
}

func init() {
	proto.RegisterType((*NewRoundRequest)(nil), "mixnet.NewRoundRequest")
	proto.RegisterType((*NewRoundResponse)(nil), "mixnet.NewRoundResponse")
	proto.RegisterType((*EndRoundRequest)(nil), "mixnet.EndRoundRequest")
	proto.RegisterType((*EndRoundResponse)(nil), "mixnet.EndRoundResponse")
	proto.RegisterType((*AddMessagesRequest)(nil), "mixnet.AddMessagesRequest")
	proto.RegisterType((*AddMessagesResponse)(nil), "mixnet.AddMessagesResponse")
	proto.RegisterType((*StartRoundRequest)(nil), "mixnet.StartRoundRequest")
	proto.RegisterType((*StartRoundResponse)(nil), "mixnet.StartRoundResponse")
	proto.RegisterType((*GetMessagesRequest)(nil), "mixnet.GetMessagesRequest")
	proto.RegisterType((*GetMessagesResponse)(nil), "mixnet.GetMessagesResponse")
	proto.RegisterType((*SubmitCiphertextsRequest)(nil), "mixnet.SubmitCiphertextsRequest")
	proto.RegisterType((*SubmitCiphertextsResponse)(nil), "mixnet.SubmitCiphertextsResponse")
	proto.RegisterType((*VerifyProofRequest)(nil), "mixnet.VerifyProofRequest")
	proto.RegisterType((*VerifyProofResponse)(nil), "mixnet.VerifyProofResponse")
	proto.RegisterType((*ConfirmVerificationRequest)(nil), "mixnet.ConfirmVerificationRequest")
	proto.RegisterType((*ConfirmVerificationResponse)(nil), "mixnet.ConfirmVerificationResponse")
	proto.RegisterType((*PrivateKey)(nil), "mixnet.PrivateKey")
	proto.RegisterType((*PublicKey)(nil), "mixnet.PublicKey")
	proto.RegisterType((*Ciphertext)(nil), "mixnet.Ciphertext")
	proto.RegisterType((*GetInnerKeyRequest)(nil), "mixnet.GetInnerKeyRequest")
	proto.RegisterType((*GetInnerKeyResponse)(nil), "mixnet.GetInnerKeyResponse")
	proto.RegisterType((*AddInnerCiphertextsRequest)(nil), "mixnet.AddInnerCiphertextsRequest")
	proto.RegisterType((*AddInnerCiphertextsResponse)(nil), "mixnet.AddInnerCiphertextsResponse")
	proto.RegisterType((*GetPrivateInnerKeyRequest)(nil), "mixnet.GetPrivateInnerKeyRequest")
	proto.RegisterType((*GetPrivateInnerKeyResponse)(nil), "mixnet.GetPrivateInnerKeyResponse")
	proto.RegisterType((*FinalizeRequest)(nil), "mixnet.FinalizeRequest")
	proto.RegisterType((*FinalizeResponse)(nil), "mixnet.FinalizeResponse")
	proto.RegisterEnum("mixnet.Source", Source_name, Source_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Mix service

type MixClient interface {
	NewRound(ctx context.Context, in *NewRoundRequest, opts ...grpc.CallOption) (*NewRoundResponse, error)
	EndRound(ctx context.Context, in *EndRoundRequest, opts ...grpc.CallOption) (*EndRoundResponse, error)
	AddMessages(ctx context.Context, opts ...grpc.CallOption) (Mix_AddMessagesClient, error)
	GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	StartRound(ctx context.Context, in *StartRoundRequest, opts ...grpc.CallOption) (*StartRoundResponse, error)
	SubmitCiphertexts(ctx context.Context, opts ...grpc.CallOption) (Mix_SubmitCiphertextsClient, error)
	VerifyProof(ctx context.Context, opts ...grpc.CallOption) (Mix_VerifyProofClient, error)
	ConfirmVerification(ctx context.Context, in *ConfirmVerificationRequest, opts ...grpc.CallOption) (*ConfirmVerificationResponse, error)
	// inner ciphertext related
	GetInnerKey(ctx context.Context, in *GetInnerKeyRequest, opts ...grpc.CallOption) (*GetInnerKeyResponse, error)
	AddInnerCiphertexts(ctx context.Context, in *AddInnerCiphertextsRequest, opts ...grpc.CallOption) (*AddInnerCiphertextsResponse, error)
	GetPrivateInnerKey(ctx context.Context, in *GetPrivateInnerKeyRequest, opts ...grpc.CallOption) (*GetPrivateInnerKeyResponse, error)
	Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error)
}

type mixClient struct {
	cc *grpc.ClientConn
}

func NewMixClient(cc *grpc.ClientConn) MixClient {
	return &mixClient{cc}
}

func (c *mixClient) NewRound(ctx context.Context, in *NewRoundRequest, opts ...grpc.CallOption) (*NewRoundResponse, error) {
	out := new(NewRoundResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/NewRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) EndRound(ctx context.Context, in *EndRoundRequest, opts ...grpc.CallOption) (*EndRoundResponse, error) {
	out := new(EndRoundResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/EndRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) AddMessages(ctx context.Context, opts ...grpc.CallOption) (Mix_AddMessagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Mix_serviceDesc.Streams[0], c.cc, "/mixnet.Mix/AddMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &mixAddMessagesClient{stream}
	return x, nil
}

type Mix_AddMessagesClient interface {
	Send(*AddMessagesRequest) error
	CloseAndRecv() (*AddMessagesResponse, error)
	grpc.ClientStream
}

type mixAddMessagesClient struct {
	grpc.ClientStream
}

func (x *mixAddMessagesClient) Send(m *AddMessagesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mixAddMessagesClient) CloseAndRecv() (*AddMessagesResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddMessagesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mixClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	out := new(GetMessagesResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/GetMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) StartRound(ctx context.Context, in *StartRoundRequest, opts ...grpc.CallOption) (*StartRoundResponse, error) {
	out := new(StartRoundResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/StartRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) SubmitCiphertexts(ctx context.Context, opts ...grpc.CallOption) (Mix_SubmitCiphertextsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Mix_serviceDesc.Streams[1], c.cc, "/mixnet.Mix/SubmitCiphertexts", opts...)
	if err != nil {
		return nil, err
	}
	x := &mixSubmitCiphertextsClient{stream}
	return x, nil
}

type Mix_SubmitCiphertextsClient interface {
	Send(*SubmitCiphertextsRequest) error
	CloseAndRecv() (*SubmitCiphertextsResponse, error)
	grpc.ClientStream
}

type mixSubmitCiphertextsClient struct {
	grpc.ClientStream
}

func (x *mixSubmitCiphertextsClient) Send(m *SubmitCiphertextsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mixSubmitCiphertextsClient) CloseAndRecv() (*SubmitCiphertextsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SubmitCiphertextsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mixClient) VerifyProof(ctx context.Context, opts ...grpc.CallOption) (Mix_VerifyProofClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Mix_serviceDesc.Streams[2], c.cc, "/mixnet.Mix/VerifyProof", opts...)
	if err != nil {
		return nil, err
	}
	x := &mixVerifyProofClient{stream}
	return x, nil
}

type Mix_VerifyProofClient interface {
	Send(*VerifyProofRequest) error
	CloseAndRecv() (*VerifyProofResponse, error)
	grpc.ClientStream
}

type mixVerifyProofClient struct {
	grpc.ClientStream
}

func (x *mixVerifyProofClient) Send(m *VerifyProofRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mixVerifyProofClient) CloseAndRecv() (*VerifyProofResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(VerifyProofResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mixClient) ConfirmVerification(ctx context.Context, in *ConfirmVerificationRequest, opts ...grpc.CallOption) (*ConfirmVerificationResponse, error) {
	out := new(ConfirmVerificationResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/ConfirmVerification", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) GetInnerKey(ctx context.Context, in *GetInnerKeyRequest, opts ...grpc.CallOption) (*GetInnerKeyResponse, error) {
	out := new(GetInnerKeyResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/GetInnerKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) AddInnerCiphertexts(ctx context.Context, in *AddInnerCiphertextsRequest, opts ...grpc.CallOption) (*AddInnerCiphertextsResponse, error) {
	out := new(AddInnerCiphertextsResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/AddInnerCiphertexts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) GetPrivateInnerKey(ctx context.Context, in *GetPrivateInnerKeyRequest, opts ...grpc.CallOption) (*GetPrivateInnerKeyResponse, error) {
	out := new(GetPrivateInnerKeyResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/GetPrivateInnerKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixClient) Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error) {
	out := new(FinalizeResponse)
	err := grpc.Invoke(ctx, "/mixnet.Mix/Finalize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Mix service

type MixServer interface {
	NewRound(context.Context, *NewRoundRequest) (*NewRoundResponse, error)
	EndRound(context.Context, *EndRoundRequest) (*EndRoundResponse, error)
	AddMessages(Mix_AddMessagesServer) error
	GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
	StartRound(context.Context, *StartRoundRequest) (*StartRoundResponse, error)
	SubmitCiphertexts(Mix_SubmitCiphertextsServer) error
	VerifyProof(Mix_VerifyProofServer) error
	ConfirmVerification(context.Context, *ConfirmVerificationRequest) (*ConfirmVerificationResponse, error)
	// inner ciphertext related
	GetInnerKey(context.Context, *GetInnerKeyRequest) (*GetInnerKeyResponse, error)
	AddInnerCiphertexts(context.Context, *AddInnerCiphertextsRequest) (*AddInnerCiphertextsResponse, error)
	GetPrivateInnerKey(context.Context, *GetPrivateInnerKeyRequest) (*GetPrivateInnerKeyResponse, error)
	Finalize(context.Context, *FinalizeRequest) (*FinalizeResponse, error)
}

func RegisterMixServer(s *grpc.Server, srv MixServer) {
	s.RegisterService(&_Mix_serviceDesc, srv)
}

func _Mix_NewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).NewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/NewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).NewRound(ctx, req.(*NewRoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_EndRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndRoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).EndRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/EndRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).EndRound(ctx, req.(*EndRoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_AddMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MixServer).AddMessages(&mixAddMessagesServer{stream})
}

type Mix_AddMessagesServer interface {
	SendAndClose(*AddMessagesResponse) error
	Recv() (*AddMessagesRequest, error)
	grpc.ServerStream
}

type mixAddMessagesServer struct {
	grpc.ServerStream
}

func (x *mixAddMessagesServer) SendAndClose(m *AddMessagesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mixAddMessagesServer) Recv() (*AddMessagesRequest, error) {
	m := new(AddMessagesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Mix_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).GetMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/GetMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).GetMessages(ctx, req.(*GetMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_StartRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).StartRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/StartRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).StartRound(ctx, req.(*StartRoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_SubmitCiphertexts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MixServer).SubmitCiphertexts(&mixSubmitCiphertextsServer{stream})
}

type Mix_SubmitCiphertextsServer interface {
	SendAndClose(*SubmitCiphertextsResponse) error
	Recv() (*SubmitCiphertextsRequest, error)
	grpc.ServerStream
}

type mixSubmitCiphertextsServer struct {
	grpc.ServerStream
}

func (x *mixSubmitCiphertextsServer) SendAndClose(m *SubmitCiphertextsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mixSubmitCiphertextsServer) Recv() (*SubmitCiphertextsRequest, error) {
	m := new(SubmitCiphertextsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Mix_VerifyProof_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MixServer).VerifyProof(&mixVerifyProofServer{stream})
}

type Mix_VerifyProofServer interface {
	SendAndClose(*VerifyProofResponse) error
	Recv() (*VerifyProofRequest, error)
	grpc.ServerStream
}

type mixVerifyProofServer struct {
	grpc.ServerStream
}

func (x *mixVerifyProofServer) SendAndClose(m *VerifyProofResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mixVerifyProofServer) Recv() (*VerifyProofRequest, error) {
	m := new(VerifyProofRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Mix_ConfirmVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmVerificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).ConfirmVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/ConfirmVerification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).ConfirmVerification(ctx, req.(*ConfirmVerificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_GetInnerKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInnerKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).GetInnerKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/GetInnerKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).GetInnerKey(ctx, req.(*GetInnerKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_AddInnerCiphertexts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInnerCiphertextsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).AddInnerCiphertexts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/AddInnerCiphertexts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).AddInnerCiphertexts(ctx, req.(*AddInnerCiphertextsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_GetPrivateInnerKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateInnerKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).GetPrivateInnerKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/GetPrivateInnerKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).GetPrivateInnerKey(ctx, req.(*GetPrivateInnerKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mix_Finalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixServer).Finalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixnet.Mix/Finalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixServer).Finalize(ctx, req.(*FinalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Mix_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixnet.Mix",
	HandlerType: (*MixServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewRound",
			Handler:    _Mix_NewRound_Handler,
		},
		{
			MethodName: "EndRound",
			Handler:    _Mix_EndRound_Handler,
		},
		{
			MethodName: "GetMessages",
			Handler:    _Mix_GetMessages_Handler,
		},
		{
			MethodName: "StartRound",
			Handler:    _Mix_StartRound_Handler,
		},
		{
			MethodName: "ConfirmVerification",
			Handler:    _Mix_ConfirmVerification_Handler,
		},
		{
			MethodName: "GetInnerKey",
			Handler:    _Mix_GetInnerKey_Handler,
		},
		{
			MethodName: "AddInnerCiphertexts",
			Handler:    _Mix_AddInnerCiphertexts_Handler,
		},
		{
			MethodName: "GetPrivateInnerKey",
			Handler:    _Mix_GetPrivateInnerKey_Handler,
		},
		{
			MethodName: "Finalize",
			Handler:    _Mix_Finalize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddMessages",
			Handler:       _Mix_AddMessages_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SubmitCiphertexts",
			Handler:       _Mix_SubmitCiphertexts_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifyProof",
			Handler:       _Mix_VerifyProof_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "mixnet.proto",
}

func (m *NewRoundRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewRoundRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *NewRoundResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewRoundResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EndRoundRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndRoundRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *EndRoundResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndRoundResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *AddMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StartRoundRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRoundRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *StartRoundResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRoundResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *GetMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SubmitCiphertextsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitCiphertextsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	if len(m.Ciphertexts) > 0 {
		for _, b := range m.Ciphertexts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SubmitCiphertextsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitCiphertextsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *VerifyProofRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyProofRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	if m.Index != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Index))
		i += 4
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Proof) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.Proof)))
		i += copy(dAtA[i:], m.Proof)
	}
	return i, nil
}

func (m *VerifyProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyProofResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ConfirmVerificationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmVerificationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	if m.Verified {
		dAtA[i] = 0x10
		i++
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ConfirmVerificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmVerificationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PrivateKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.X) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.X)))
		i += copy(dAtA[i:], m.X)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.X) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.X)))
		i += copy(dAtA[i:], m.X)
	}
	if len(m.Y) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.Y)))
		i += copy(dAtA[i:], m.Y)
	}
	return i, nil
}

func (m *Ciphertext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ciphertext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.X) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.X)))
		i += copy(dAtA[i:], m.X)
	}
	if len(m.Y) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.Y)))
		i += copy(dAtA[i:], m.Y)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *GetInnerKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInnerKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *GetInnerKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInnerKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.X) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.X)))
		i += copy(dAtA[i:], m.X)
	}
	if len(m.Y) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.Y)))
		i += copy(dAtA[i:], m.Y)
	}
	return i, nil
}

func (m *AddInnerCiphertextsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddInnerCiphertextsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *AddInnerCiphertextsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddInnerCiphertextsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetPrivateInnerKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateInnerKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *GetPrivateInnerKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateInnerKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrivateKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMixnet(dAtA, i, uint64(len(m.PrivateKey)))
		i += copy(dAtA[i:], m.PrivateKey)
	}
	return i, nil
}

func (m *FinalizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalizeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Round))
		i += 8
	}
	return i, nil
}

func (m *FinalizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalizeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plaintexts) > 0 {
		for _, b := range m.Plaintexts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMixnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func encodeVarintMixnet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NewRoundRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *NewRoundResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EndRoundRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *EndRoundResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddMessagesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	return n
}

func (m *AddMessagesResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StartRoundRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *StartRoundResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetMessagesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *GetMessagesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	return n
}

func (m *SubmitCiphertextsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	if len(m.Ciphertexts) > 0 {
		for _, b := range m.Ciphertexts {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	return n
}

func (m *SubmitCiphertextsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *VerifyProofRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	if m.Index != 0 {
		n += 5
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *VerifyProofResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ConfirmVerificationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	if m.Verified {
		n += 2
	}
	return n
}

func (m *ConfirmVerificationResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PrivateKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *Ciphertext) Size() (n int) {
	var l int
	_ = l
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *GetInnerKeyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *GetInnerKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *AddInnerCiphertextsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	return n
}

func (m *AddInnerCiphertextsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetPrivateInnerKeyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *GetPrivateInnerKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovMixnet(uint64(l))
	}
	return n
}

func (m *FinalizeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 9
	}
	return n
}

func (m *FinalizeResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Plaintexts) > 0 {
		for _, b := range m.Plaintexts {
			l = len(b)
			n += 1 + l + sovMixnet(uint64(l))
		}
	}
	return n
}

func sovMixnet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMixnet(x uint64) (n int) {
	return sovMixnet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NewRoundRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRoundRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRoundRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewRoundResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRoundResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRoundResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndRoundRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndRoundRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndRoundRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndRoundResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndRoundResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndRoundResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, make([]byte, postIndex-iNdEx))
			copy(m.Messages[len(m.Messages)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRoundRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRoundRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRoundRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRoundResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRoundResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRoundResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, make([]byte, postIndex-iNdEx))
			copy(m.Messages[len(m.Messages)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitCiphertextsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitCiphertextsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitCiphertextsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertexts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertexts = append(m.Ciphertexts, make([]byte, postIndex-iNdEx))
			copy(m.Ciphertexts[len(m.Ciphertexts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, make([]byte, postIndex-iNdEx))
			copy(m.Proofs[len(m.Proofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitCiphertextsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitCiphertextsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitCiphertextsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyProofRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyProofRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyProofRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmVerificationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmVerificationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmVerificationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmVerificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmVerificationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmVerificationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = append(m.Y[:0], dAtA[iNdEx:postIndex]...)
			if m.Y == nil {
				m.Y = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ciphertext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ciphertext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ciphertext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = append(m.Y[:0], dAtA[iNdEx:postIndex]...)
			if m.Y == nil {
				m.Y = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInnerKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInnerKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInnerKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInnerKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInnerKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInnerKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = append(m.Y[:0], dAtA[iNdEx:postIndex]...)
			if m.Y == nil {
				m.Y = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddInnerCiphertextsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddInnerCiphertextsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddInnerCiphertextsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, make([]byte, postIndex-iNdEx))
			copy(m.Messages[len(m.Messages)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddInnerCiphertextsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddInnerCiphertextsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddInnerCiphertextsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateInnerKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateInnerKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateInnerKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateInnerKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateInnerKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateInnerKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintexts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMixnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plaintexts = append(m.Plaintexts, make([]byte, postIndex-iNdEx))
			copy(m.Plaintexts[len(m.Plaintexts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMixnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMixnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMixnet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMixnet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMixnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMixnet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMixnet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMixnet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMixnet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMixnet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mixnet.proto", fileDescriptorMixnet) }

var fileDescriptorMixnet = []byte{
	// 741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xdf, 0x52, 0xd3, 0x4e,
	0x14, 0x4e, 0xe8, 0x8f, 0xc2, 0xef, 0xb4, 0x33, 0x96, 0x03, 0x6a, 0xd8, 0x0e, 0x35, 0xac, 0x17,
	0x54, 0x2e, 0x98, 0x01, 0xaf, 0x1d, 0x07, 0x98, 0x82, 0x80, 0x74, 0x98, 0xd4, 0xe1, 0x4a, 0x47,
	0x4b, 0xb3, 0xe8, 0x02, 0x4d, 0x62, 0x92, 0x62, 0xe3, 0x93, 0xf8, 0x30, 0x3e, 0x80, 0x97, 0x3e,
	0x82, 0x83, 0x2f, 0xe2, 0x24, 0xd9, 0x74, 0xd3, 0x24, 0x84, 0xde, 0xf5, 0x64, 0xbf, 0xf3, 0x9d,
	0x3f, 0xbb, 0xdf, 0x37, 0x85, 0xfa, 0x90, 0x8f, 0x2d, 0xe6, 0x6f, 0x39, 0xae, 0xed, 0xdb, 0x58,
	0x8d, 0x23, 0xba, 0x01, 0x8f, 0xba, 0xec, 0x9b, 0x61, 0x8f, 0x2c, 0xd3, 0x60, 0x5f, 0x47, 0xcc,
	0xf3, 0x71, 0x05, 0xe6, 0xdd, 0x30, 0xd6, 0x54, 0x5d, 0x6d, 0x57, 0x8d, 0x38, 0xa0, 0x08, 0x0d,
	0x09, 0xf4, 0x1c, 0xdb, 0xf2, 0x58, 0x98, 0xdc, 0xb1, 0xcc, 0xd9, 0x92, 0x25, 0x50, 0x24, 0x1f,
	0x00, 0xee, 0x9a, 0xe6, 0x29, 0xf3, 0xbc, 0xfe, 0x67, 0xe6, 0x95, 0xe6, 0x23, 0x81, 0xc5, 0xa1,
	0x00, 0x6a, 0x73, 0x7a, 0xa5, 0x5d, 0x37, 0x26, 0x31, 0x7d, 0x0c, 0xcb, 0x53, 0x3c, 0x82, 0xfe,
	0x05, 0x2c, 0xf5, 0xfc, 0xbe, 0xeb, 0xcf, 0xd0, 0xdd, 0x0a, 0x60, 0x1a, 0x2a, 0x08, 0x36, 0x01,
	0x0f, 0x99, 0x3f, 0x53, 0x7f, 0x74, 0x1b, 0x96, 0xa7, 0xb0, 0x31, 0xc5, 0x54, 0xdb, 0x6a, 0xa6,
	0xed, 0x2b, 0xd0, 0x7a, 0xa3, 0x8b, 0x21, 0xf7, 0xf7, 0xb9, 0xf3, 0x85, 0xb9, 0x3e, 0x1b, 0xfb,
	0x0f, 0x2c, 0x41, 0x87, 0xda, 0x40, 0x62, 0xc5, 0x1e, 0xd2, 0x9f, 0xf0, 0x09, 0x54, 0x1d, 0xd7,
	0xb6, 0x2f, 0x3d, 0xad, 0x12, 0x1d, 0x8a, 0x88, 0x36, 0x61, 0xb5, 0xa0, 0x96, 0x98, 0xf3, 0x0a,
	0xf0, 0x9c, 0xb9, 0xfc, 0x32, 0x38, 0x0b, 0xc1, 0xe5, 0x2d, 0xac, 0xc0, 0x3c, 0xb7, 0x4c, 0x36,
	0xd6, 0xe6, 0x74, 0xb5, 0xbd, 0x60, 0xc4, 0x01, 0x22, 0xfc, 0x77, 0xcd, 0x82, 0xa4, 0x68, 0xf4,
	0x3b, 0x44, 0x46, 0xc5, 0xb5, 0x79, 0x5d, 0x6d, 0xd7, 0x8d, 0x38, 0x08, 0xef, 0x6a, 0xaa, 0x96,
	0x68, 0xa1, 0x0b, 0x64, 0xdf, 0xb6, 0x2e, 0xb9, 0x3b, 0x8c, 0x4e, 0xf9, 0xa0, 0xef, 0x73, 0xdb,
	0x7a, 0xf0, 0x49, 0xdc, 0x46, 0x60, 0x66, 0x46, 0xdd, 0x2c, 0x1a, 0x93, 0x98, 0xae, 0x41, 0xb3,
	0x90, 0x4f, 0x94, 0x23, 0x00, 0x67, 0x2e, 0xbf, 0xed, 0xfb, 0xec, 0x84, 0x05, 0x58, 0x07, 0x75,
	0x1c, 0x51, 0xd7, 0x0d, 0x75, 0x4c, 0x37, 0xe0, 0xff, 0xb3, 0xd1, 0xc5, 0x0d, 0x1f, 0xe4, 0x8e,
	0xc2, 0x28, 0x88, 0x4a, 0xd5, 0x0d, 0x35, 0xa0, 0x7b, 0x00, 0x72, 0x9b, 0x65, 0x48, 0xd4, 0x60,
	0x41, 0xdc, 0xba, 0x56, 0x89, 0xbe, 0x25, 0xa1, 0x78, 0x62, 0x47, 0x96, 0xc5, 0xdc, 0x13, 0x16,
	0xcc, 0xf2, 0xc4, 0x24, 0x56, 0x3c, 0xb1, 0xb2, 0x16, 0xbb, 0x40, 0x76, 0x4d, 0x33, 0x4a, 0x99,
	0xf9, 0x91, 0x95, 0x29, 0x6d, 0x0d, 0x9a, 0x85, 0x7c, 0x62, 0xad, 0xdb, 0xb0, 0x7a, 0xc8, 0x7c,
	0xb1, 0xd9, 0xd9, 0x86, 0x7a, 0x05, 0xa4, 0x28, 0x45, 0xcc, 0xf6, 0x0c, 0x6a, 0x4e, 0x7c, 0xf4,
	0xf1, 0x9a, 0x05, 0x62, 0x4a, 0x70, 0x26, 0x57, 0x17, 0xfa, 0xcf, 0x01, 0xb7, 0xfa, 0x37, 0xfc,
	0x3b, 0x2b, 0xaf, 0xb3, 0x03, 0x0d, 0x09, 0x14, 0xec, 0x2d, 0x00, 0xe7, 0xa6, 0xcf, 0xad, 0x58,
	0x4d, 0xb1, 0x3c, 0x53, 0x5f, 0x36, 0x75, 0xa8, 0xf6, 0xec, 0x91, 0x3b, 0x60, 0x08, 0x50, 0xdd,
	0x7f, 0x7b, 0xd4, 0xe9, 0xbe, 0x6b, 0x28, 0xe1, 0xef, 0x5e, 0xc7, 0x38, 0xef, 0x18, 0x0d, 0x75,
	0xe7, 0xe7, 0x02, 0x54, 0x4e, 0xf9, 0x18, 0x5f, 0xc3, 0x62, 0x62, 0x8d, 0xf8, 0x74, 0x4b, 0xd8,
	0x6c, 0xc6, 0x55, 0x89, 0x96, 0x3f, 0x10, 0x7b, 0x53, 0x42, 0x82, 0xc4, 0x1e, 0x25, 0x41, 0xc6,
	0x59, 0x25, 0x41, 0xce, 0x49, 0x15, 0x3c, 0x86, 0x5a, 0xca, 0x03, 0x91, 0x24, 0xd0, 0xbc, 0xc1,
	0x92, 0x66, 0xe1, 0x59, 0xc2, 0xd4, 0x56, 0xf1, 0x0d, 0xd4, 0x52, 0x5e, 0x26, 0xb9, 0xf2, 0x66,
	0x28, 0xb9, 0x0a, 0xcc, 0x8f, 0x2a, 0xd8, 0x01, 0x90, 0xbe, 0x8a, 0xab, 0x09, 0x38, 0x67, 0xcb,
	0x84, 0x14, 0x1d, 0x4d, 0x68, 0xde, 0xc3, 0x52, 0xce, 0xbd, 0x50, 0x9f, 0xa4, 0xdc, 0x63, 0xa2,
	0x64, 0xbd, 0x04, 0x91, 0x1a, 0xf7, 0x18, 0x6a, 0x29, 0x4b, 0x92, 0xe3, 0xe6, 0x3d, 0x51, 0x8e,
	0x5b, 0xe4, 0x61, 0x21, 0xd7, 0x27, 0x58, 0x2e, 0xf0, 0x1d, 0xa4, 0x49, 0xde, 0xfd, 0x26, 0x47,
	0x9e, 0x97, 0x62, 0x26, 0xbb, 0x88, 0x2f, 0x27, 0x51, 0xca, 0xd4, 0xe5, 0x64, 0x14, 0x37, 0x75,
	0x39, 0x59, 0x69, 0x51, 0x25, 0xec, 0xb5, 0x40, 0xcc, 0xb2, 0xd7, 0xfb, 0x9d, 0x43, 0xf6, 0x5a,
	0xe6, 0x06, 0x0a, 0x7e, 0x88, 0xdc, 0x2d, 0x23, 0x6e, 0x5c, 0x4f, 0xb5, 0x55, 0xec, 0x15, 0x84,
	0x96, 0x41, 0xd2, 0xa2, 0x49, 0x34, 0x2d, 0x45, 0x93, 0xb1, 0x03, 0x29, 0x9a, 0xac, 0xfc, 0xa9,
	0xb2, 0xd7, 0xf8, 0x75, 0xd7, 0x52, 0x7f, 0xdf, 0xb5, 0xd4, 0x3f, 0x77, 0x2d, 0xf5, 0xc7, 0xdf,
	0x96, 0x72, 0x51, 0x8d, 0xfe, 0x1b, 0xbd, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0xd1, 0x7c, 0x0c,
	0xfb, 0x2b, 0x09, 0x00, 0x00,
}
